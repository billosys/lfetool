#!/bin/sh

# OS Type
OS_TYPE=Unix
case `uname -s` in
    CYGWIN_NT*)
        OS_TYPE=Cygwin
        ;;
    Windows_NT)
        OS_TYPE=Windows
        ;;
    SunOS)
        case `uname -r` in
            4*) OS_TYPE=SunBSD ;;
            5*) OS_TYPE=Solaris ;;
        esac
        ;;
    Linux)
        OS_TYPE=Linux
        ;;
    Darwin)
        OS_TYPE=Darwin
        ;;
    AIX)
        OS_TYPE=AIX
        ;;
    HP-UX)
        OS_TYPE=HP-UX
        ;;
    OSF1)
        OS_TYPE=OSF1
        ;;

    *)
        ;;
esac

# readlink -f doesn't work on Mac OS X, so this hack is needed
absfile () {
    abspath="$(cd "$(dirname "$0")"; pwd)"
    echo $abspath/$(basename $0)
}

CWD=$(pwd)
SCRIPT_PATH=$(readlink $0)
if [ -z $SCRIPT_PATH ]; then
    SCRIPT_PATH=$(absfile $0)
fi
BIN_DIR=$(dirname $SCRIPT_PATH)
EXEC_DIR=$(dirname $BIN_DIR)
LFETOOL=lfetool2
case $OS_TYPE in
    Cygwin|Windows)
        ERL=werl
        ;;
    *)
        ERL=erl
        ;;
esac

error () {
    message=$1
    echo
    echo $message
    echo
    print_usage $script
    exit 1
}

unknown_subcommand_error () {
    command=$1
    subcommand=$2
    error "Unknown subcommand for '$command': '$subcommand'";
}

getpath () {
    echo $BIN_DIR:`$LFETOOL info path`:$PATH
}

geterllibs () {
    $LFETOOL info erllibs
}

configrlwrap () {
    echo "rlwrap --command=$1 --prompt-colour=YELLOW --histsize=100000 --remember"
}

checkerjang () {
    if [ "$ERJANG_HOME" == "" ]; then
        echo
        echo "Error: undefined \$ERJANG_HOME variable."
        echo
        echo "In order to use Erjang/jlfe, you need to define the \$ERJANG_HOME"
        echo "environment variable."
        echo
        exit 1
    fi
}

lfetooleval () {
    ARGS="$*"
    if [ "$1" == "debug" ]; then
        DEBUG="-debug true"
        ARGS="${@:2}"
    else
        DEBUG=""
    fi
    if [ "$1" == "tests" ] && [ "$3" != "" ]; then
        LISTENER="-listener $3"
        ARGS="${@:0:$#}"
    else
        LISTENER=""
    fi
    cd $EXEC_DIR && ERL_LIBS=.:$(lfetool info erllibs):~/.lfetool:. \
    erl \
        -cwd "$CWD" \
        -s lfetool \
        $DEBUG \
        $LISTENER \
        -eval "case lfetool:eval(\"$ARGS\") of
                 ok ->
                   halt(0);
                 _ -> halt(127)
               end" \
        -noshell
}

dorepl () {
    subcommand=$1
    shift 1
    if [ x"$subcommand" = x ]; then
        subcommand="lfe"
    fi
    case $subcommand in
        lfe)
            PATH=`getpath` ERL_LIBS=`geterllibs` lfe "$@" -cwd "$CWD" -s lfetool
            exit $!
            ;;
        erlang|erl)
            PATH=`getpath` ERL_LIBS=`geterllibs` erl "$@" -cwd "$CWD" -s lfetool
            exit $!
            ;;
        erjang|jerl)
            checkerjang
            PATH=`getpath`:$ERJANG_HOME ERL_LIBS=`geterllibs` \
                `configrlwrap jerl` \
                jerl "$@"
            exit $!
            ;;
        jlfe)
            checkerjang
            PATH=`getpath`:$ERJANG_HOME ERL_LIBS=`geterllibs` \
                `configrlwrap jerl` \
                jerl -noshell -s lfe_shell "$@"
            exit $!
            ;;
        *)
            unknown_subcommand_error repl $subcommand
            exit $!
            ;;
    esac
}

buildlfe () {
    cd deps/lfe && make erlc_compile
    cd - >/dev/null
}

buildlutil () {
    cd deps/lutil && ERL_LIBS=../lfe PATH=../lfe/bin:$PATH \
    lfec -o ./ebin ./src/*.lfe && \
    cp ./src/lutil.app.src ./ebin/lutil.app
    cd - >/dev/null
}

buildlfetool () {
    ERL_LIBS=../lfe PATH=../lfe/bin:$PATH \
    lfec -o ./ebin ./src/*.lfe && \
    cp ./src/lfetool.app.src ./ebin/lfetool.app
}

dobootstrap () {
    subcommand=$1
    shift 1
    if [ x"$subcommand" = x ]; then
        subcommand="build"
    fi
    case $subcommand in
        build)
            echo "Bootstrapping LFE ..."
            buildlfe
            echo "Bootstrapping lutil ..."
            buildlutil
            echo "Bootstrapping lfetool ..."
            buildlfetool
            exit 0
            ;;
        *)
            unknown_subcommand_error bootstrap $subcommand
            exit $!
            ;;
    esac
}

run () {
    command=$1
    shift 1
    rest="$@"
    case $command in
        # offer backwards compatibility for flags
        -c)
            command=commands
            rest=""
            ;;
        -d)
            command=debug
            ;;
        -h)
            command=help
            ;;
        -u)
            command=usage
            rest=""
            ;;
        -v)
            command=version
            rest=""
            ;;
        -x)
            command=extract
            rest=""
            ;;
        repl)
            dorepl $rest
            ;;
        bootstrap)
            dobootstrap $rest
            ;;
    esac
    lfetooleval $command $rest
}

run "$@"
