gitignore="{{GITIGNORE}}"
usage="{{USAGE}}"
rebarconfig="{{REBAR}}"
package="{{PACKAGE}}"
commonmk="{{COMMONMK}}"
otpmk="{{OTPMK}}"
yawsmk="{{YAWSMK}}"
libmakefile="{{LIBMAKEFILE}}"
svcmakefile="{{SVCMAKEFILE}}"
travisci="{{TRAVISCI}}"
readme="{{README}}"
scriptfile="{{SCRIPTFILE}}"
libappsrc="{{LIBAPPSRC}}"
libtestmodule="{{LIBTESTMODULE}}"
libmodule="{{LIBMODULE}}"
svcappsrc="{{SVCAPPSRC}}"
svctestmodule="{{SVCTESTMODULE}}"
svcapp="{{SVCAPP}}"
svcserver="{{SVCSERVER}}"
svcsup="{{SVCSUP}}"
yawsmakefile="{{YAWSMAKEFILE}}"
yawsrebar="{{YAWSREBAR}}"
yawsconf="{{YAWSCONF}}"
yawsmodule="{{YAWSMODULE}}"
yawsroutesmodule="{{YAWSROUTESMODULE}}"
yawscontentmodule="{{YAWSCONTENTMODULE}}"
yawsutilmodule="{{YAWSUTILMODULE}}"
yawsbootstrapcontentmodule="{{YAWSBOOTSTRAPCONTENTMODULE}}"
yawsbootstrapnavmodule="{{YAWSBOOTSTRAPNAVMODULE}}"
yawsbootstraproutesmodule="{{YAWSBOOTSTRAPROUTESMODULE}}"
yawsbootstrapcss="{{YAWSBOOTSTRAPCSS}}"
yawsbootstrapcssmin="{{YAWSBOOTSTRAPCSSMIN}}"
yawsbootstrapslatecss="{{YAWSBOOTSTRAPCSSSLATE}}"
yawsbootstrapslatecssmin="{{YAWSBOOTSTRAPCSSMINSLATE}}"
yawsbootstrapjs="{{YAWSBOOTSTRAPJS}}"
yawsbootstrapjsmin="{{YAWSBOOTSTRAPJSMIN}}"
yawsbootstrapfonteot="{{YAWSBOOTSTRAPFONTEOT}}"
yawsbootstrapfontsvg="{{YAWSBOOTSTRAPFONTSVG}}"
yawsbootstrapfontttf="{{YAWSBOOTSTRAPFONTTTF}}"
yawsbootstrapfontwoff="{{YAWSBOOTSTRAPFONTWOFF}}"

DEPS=./deps
TEST_DIR=./test
TEST_OUT_DIR=./.eunit
CASE_OPEN="case eunit:test({inparallel,["
CASE_CLOSE="]},[verbose]) of ok -> halt(0); _ -> halt(127) end"

BLACK="\033[0;30;40m"
RED="\033[0;31;40m"
GREEN="\033[0;32;40m"
YELLOW="\033[0;33;40m"
BLUE="\033[0;34;40m"
MAGENTA="\033[0;35;40m"
CYAN="\033[0;36;40m"
WHITE="\033[0;37;40m"
BOLD_BLACK="\033[1;30;40m"
BOLD_RED="\033[1;31;40m"
BOLD_GREEN="\033[1;32;40m"
BOLD_YELLOW="\033[1;33;40m"
BOLD_BLUE="\033[1;34;40m"
BOLD_MAGENTA="\033[1;35;40m"
BOLD_CYAN="\033[1;36;40m"
BOLD_WHITE="\033[1;37;40m"
END_COLOR="\033[m"

decode () {
    os=`uname`
    case $os in
        Darwin)
            base64 -D
            ;;
        *)
            base64 -d
            ;;
    esac
}

print-usage () {
    local fullpath=$1
    local version=$2
    local script=`basename $fullpath`
    echo "$usage" | decode | sed \
        -e "s#{{SCRIPT}}#$script#g" \
        -e "s#{{FULLPATH}}#$fullpath#g" \
        -e "s#{{VERSION}}#$version#g"
}

error () {
    local message=$1
    echo
    echo $message
    echo
    print-usage $script
    exit 1
}

unknown-command-error () {
    local command=$1
    error "Unknown command: '$command'";
}

unknown-subcommand-error () {
    local command=$1
    local subcommand=$2
    error "Unknown subcommand for '$command': '$subcommand'";
}

unknown-context-error () {
    local context=$1
    error "Unknown context: '$context'";
}

missing-context-error () {
    error "Error: command requires context"
}

missing-arg-error () {
    error "Error: context requires arg"
}

not-implemented-error () {
    error "Error: not yet implemented"
}

lfetool-not-found-error () {
    error 'Error: could not find `lfetool` on the $PATH'
}

clone-repo () {
    git clone $url
}

download-file () {
    url=$1
    curl -O "$url" && echo "Download succeeded." || echo "Download failed."
}

install-file () {
    local src=$1
    local directory=$2
    local mode=$3
    local msg=""
    if [ "$directory" = "" ]; then
        directory=/usr/local/bin
    fi
    chmod 755 $src
    if [ "$mode" = "" ]; then
        echo
        success="Installed $src to $directory."
        failure="Failed to install $src."
    else
        success="Updated $directory."
        failure="Update failed."
    fi
    mv $src $directory && echo $success || echo $failure
}

install-lfetool () {
    local directory=$1
    local mode=$2
    local url="https://raw.github.com/lfe/lfetool/master/lfetool"
    local file=lfetool
    download-file $url
    install-file $file $directory
}

install-lfe () {
    local directory=$1
    local url="https://github.com/rvirding/lfe.git"
    local repo=lfe
    local file=$repo
    clone-repo $url
    cd $repo && make compile && \
    ERL_LIBS=`erl -eval 'io:fwrite(code:lib_dir()), halt().' -noshell` \
        make install && \
    rm -rf $repo && \
    cd - &> /dev/null
}

install-erlang () {
    local release=$1
    local directory=$2
    if [ "$directory" = "" ]; then
        directory=/opt/erlang/$release
    fi
    kerl build $1 $1 && \
    kerl install $release $directory && \
    echo "Installed Erlang." || echo "Failed to install Erlang."
}

install-kerl () {
    local directory=$1
    local url="https://raw.github.com/spawngrid/kerl/master/kerl"
    local file=kerl
    download-file $url
    install-file $file $directory
}

install-rebar () {
    local directory=$1
    local url="https://github.com/rebar/rebar.git"
    local repo=rebar
    local file=$repo
    clone-repo $url
    cd $repo && make && \
    install-file $file $directory && \
    rm -rf $repo && \
    cd - &> /dev/null
}

install-relx () {
    local directory=$1
    local url="https://github.com/erlware/relx.git"
    local repo=relx
    local file=$repo
    clone-repo $url
    cd $repo && make && \
    install-file $file $directory && \
    rm -rf $repo && \
    cd - &> /dev/null
}

_install-autocomplete () {
    local directory="~/.lfetool/"
    local file="bash-complete"
    local url="https://raw.github.com/lfe/lfetool/master/$file"
    mkdir -p $directory
    download-file $url
    install-file $file $directory
}

install-autocomplete () {
    _install-autocomplete
    echo
    echo "The lfetool autocomplete file has been created. To use, simply"
    echo "update your ~/.bashrc, ~/.bash_profile, or ~/.profile to include the"
    echo "following line:"
    echo
    echo "    source ${directory}${file}"
    echo
    echo "(Alternatively, you may execute that from the command line for"
    echo "temporary use.)"
    echo
}

update-lfetool () {
    local path=`which lfetool`
    if [ "$path" = "" ]; then
      lfetool-not-found-error
    fi
    local directory=`dirname $path`
    install-lfetool $directory "update"
    echo
    echo "Updated lfetool at $path."
    _install-autocomplete
    echo "Updated lfetool autocompletion file at ~/.lfetool/bash-complete."
}

get-path () {
    echo $PATH:./deps/lfe/bin
}

get-erl-libs () {
    find $DEPS -maxdepth 1 -exec echo -n '{}:' \;|sed 's/:$/:$TEST_OUT_DIR:./'
}

clean-test-name () {
    sed -e 's/.beam//' -e 's/^.eunit\///'
}

quote-test () {
    awk '{print "\x27" $1 "\x27"}'
}

strip-newlines () {
    tr '\n' ','|sed 's/,$//'
}

get-unit-tests () {
    ls .eunit/unit*|clean-test-name|quote-test|strip-newlines
}

get-integration-tests () {
    ls .eunit/integration*|clean-test-name|quote-test|strip-newlines
}

get-system-tests () {
    ls .eunit/system*|clean-test-name|quote-test|strip-newlines
}

parse-test-results () {
    # color the successes
    sed "s/ok$/\[\\${BOLD_GREEN}ok\\${END_COLOR}\]/g" | \
    sed "s/\(Passed: .*\.\)/\\${GREEN}\1\\${END_COLOR}/" | \
    # color warnings and the like
    sed "s/There were no tests to run\./\\${YELLOW}There were no tests of this type to run\.\\${END_COLOR}/" | \
    sed "s/\(Skipped: .*\.\)/\\${YELLOW}\1\\${END_COLOR}/" | \
    # color failures
    sed "s/\*failed\*$/\[\\${RED}failed\\${END_COLOR}\]/g" | \
    sed "s/\(Failed: .*\.\)/\\${RED}\1\\${END_COLOR}/" | \
    sed "s/\(\*\*error:.*\)/\\${BOLD_RED}\1\\${END_COLOR}/" | \
    sed "s/\(                     {.*\)/\\${BOLD_RED}\1\\${END_COLOR}/" | \
    # get rid of the redundant module prefixing for each line ...
    sed "s/  unit-.*-tests:/ /" | \
    sed "s/  integration-.*-tests:/ /" | \
    sed "s/  system-.*-tests:/ /" | \
    sed "s/ (module '.*')/ /" | \
    # get rid of the eunit/erlang-only '_test' suffix
    sed "s/_test .../ ... /" | \
    sed "s/_test.../ ... /" | \
    # color the timings
    sed "s/\(.*\)\(\[[0-9].* s\]\)\(.*\)/\1\\${BOLD_BLACK}\2\\${END_COLOR}\3/" | \
    sed "s/\(.*\)\(\[done in \(.* s\)\]\)\(.*\)/\1\\${BOLD_BLACK}Total module test time: \3\\${END_COLOR}\4/"
}

build-tests () {
    echo -e "${YELLOW}Removing old tests ...${END_COLOR}"
    echo "rm -rf $TEST_OUT_DIR"
    mkdir -vp $TEST_OUT_DIR
    echo -e "${YELLOW}Compiling tests ...${END_COLOR}"
    # compile any custom testing-centric modules needed only for running tests
    PATH=`get-path` ERL_LIBS=`get-erl-libs` \
        lfec -o $TEST_OUT_DIR $TEST_DIR/testing[-_]*.lfe && \
        echo -e "${GREEN}Successfully compiled testing support modules." || \
        echo -e "${RED}Could not compile one or more testing support modules."
        echo -ne "$END_COLOR"
    # compile actual test modules (unit, integration, system, etc.)
    PATH=`get-path` ERL_LIBS=`get-erl-libs` \
        lfec -o $TEST_OUT_DIR $TEST_DIR/*/*[_-]tests.lfe && \
        echo -e "${GREEN}Successfully compiled test modules." || \
        echo -e "${RED}Could not compile one or more test modules."
        echo -ne "$END_COLOR"
}

only-run-unit-tests () {
    echo -e "$BOLD_BLUE"
    echo "------------------"
    echo "Running unit tests ..."
    echo "------------------"
    echo -e "$END_COLOR"
    result=$(PATH=`get-path` ERL_LIBS=`get-erl-libs` \
        erl -pa .eunit -noshell \
        -eval "$CASE_OPEN `get-unit-tests` $CASE_CLOSE"| \
        parse-test-results)
    echo -e "$result"
}

run-unit-tests () {
    build-tests
    only-run-unit-tests
}

only-run-integration-tests () {
    echo -e "$BOLD_BLUE"
    echo "-------------------------"
    echo "Running integration tests ..."
    echo "-------------------------"
    echo -e "$END_COLOR"
    result=$(PATH=`get-path` ERL_LIBS=`get-erl-libs` \
        erl -pa .eunit -noshell \
        -eval "$CASE_OPEN `get-integration-tests` $CASE_CLOSE"| \
        parse-test-results)
    echo -e "$result"
}

run-integration-tests () {
    build-tests
    only-run-integration-tests
}

only-run-system-tests () {
    echo -e "$BOLD_BLUE"
    echo "--------------------"
    echo "Running system tests ..."
    echo "--------------------"
    echo -e "$END_COLOR"
    result=$(PATH=`get-path` ERL_LIBS=`get-erl-libs` \
        erl -pa .eunit -noshell \
        -eval "$CASE_OPEN `get-system-tests` $CASE_CLOSE"| \
        parse-test-results)
    echo -e "$result"
}

run-system-tests () {
    build-tests
    only-run-system-tests
}

run-all-tests () {
    local failure=0
    build-tests && \
    only-run-unit-tests && \
    only-run-integration-tests && \
    only-run-system-tests
}

create-dirs () {
    local project=$1
    mkdir -p $project/{src,test/unit,test/integration,test/system}
}

create-yaws-dirs () {
    local project=$1
    mkdir -p $project/{www,etc,logs}
}

create-yaws-bootstrap-dirs () {
    local project=$1
    mkdir -p $project/{www/css,www/images,www/js,www/icons,www/fonts}
}

add-git-files () {
    git init && git add * .gitignore .travis.yml
}

create-file () {
    local data=$1
    local filename=$2
    local pattern=$3
    local project=$4
    if [ "$pattern" = "" ]; then
        pattern="{{IGNORE}}"
        project="{{IGNORE}}"
    fi
    echo $data | decode | LC_CTYPE=C LANG=C sed \
        "s#$pattern#$project#g" > $filename
}

create-project-files () {
    local project=$1
    create-file "$gitignore" $project/.gitignore
    create-file "$rebarconfig" $project/rebar.config
    create-file "$commonmk" $project/common.mk {{PROJECT}} $project
    create-file "$travisci" $project/.travis.yml {{PROJECT}} $project
    create-file "$readme" $project/README.rst {{PROJECT}} $project
    create-file "$package" $project/package.exs {{PROJECT}} $project
}

create-library-files () {
    local project=$1
    create-file "$libmakefile" $project/Makefile {{PROJECT}} $project
    create-file "$libappsrc" $project/src/$project.app.src {{PROJECT}} $project
    create-file "$libtestmodule" \
        $project/test/unit/unit-${project}-tests.lfe {{PROJECT}} $project
    create-file "$libmodule" $project/src/$project.lfe {{PROJECT}} $project
}

create-service-files () {
    local project=$1
    create-file "$otpmk" $project/otp.mk {{PROJECT}} $project
    create-file "$svcmakefile" $project/Makefile {{PROJECT}} $project
    create-file "$svcappsrc" $project/src/$project.app.src {{PROJECT}} $project
    create-file "$svctestmodule" \
        $project/test/unit/unit-${project}-tests.lfe {{PROJECT}} $project
    create-file "$svcapp" \
        $project/src/${project}-app.lfe {{PROJECT}} $project
    create-file "$svcserver" \
        $project/src/${project}-server.lfe {{PROJECT}} $project
    create-file "$svcsup" \
        $project/src/${project}-sup.lfe {{PROJECT}} $project
}

create-yaws-files () {
    local project=$1
    create-file "$yawsmk" $project/yaws.mk {{PROJECT}} $project
    create-file "$yawsmakefile" $project/Makefile {{PROJECT}} $project
    create-file "$yawsrebar" $project/rebar.config
    create-file "$yawsconf" $project/etc/yaws.conf {{PROJECT}} $project
    create-file "$svcappsrc" $project/src/$project.app.src {{PROJECT}} $project
    create-file "$yawsmodule" $project/src/${project}.lfe {{PROJECT}} $project
    create-file "$yawsroutesmodule" \
        $project/src/${project}-routes.lfe {{PROJECT}} $project
    create-file "$yawscontentmodule" \
        $project/src/${project}-content.lfe {{PROJECT}} $project
    create-file "$yawsutilmodule" \
        $project/src/${project}-util.lfe {{PROJECT}} $project
    create-file "$libtestmodule" \
        $project/test/unit/unit-${project}-tests.lfe {{PROJECT}} $project
}

create-yaws-bootstrap-files () {
    local project=$1
    create-file "$yawsbootstrapcontentmodule" \
        $project/src/${project}-content.lfe {{PROJECT}} $project
    create-file "$yawsbootstrapnavmodule" \
        $project/src/${project}-nav.lfe {{PROJECT}} $project
    create-file "$yawsbootstraproutesmodule" \
        $project/src/${project}-routes.lfe {{PROJECT}} $project
    create-file "$yawsbootstrapcss" $project/www/css/bootstrap.css
    create-file "$yawsbootstrapcssmin" $project/www/css/bootstrap-min.css
    create-file "$yawsbootstrapslatecss" $project/www/css/bootstrap-slate.css
    create-file "$yawsbootstrapslatecssmin" \
        $project/www/css/bootstrap-slate-min.css
    create-file "$yawsbootstrapjs" $project/www/js/bootstrap.js
    create-file "$yawsbootstrapcssmin" $project/www/css/bootstrap-min.css
    create-file "$yawsbootstrapjs" $project/www/js/bootstrap.js
    create-file "$yawsbootstrapjsmin" $project/www/js/bootstrap-min.js
    create-file "$yawsbootstrapfonteot" \
        $project/www/fonts/glyphicons-halflings-regular.eot
    create-file "$yawsbootstrapfontsvg" \
        $project/www/fonts/glyphicons-halflings-regular.svg
    create-file "$yawsbootstrapfontttf" \
        $project/www/fonts/glyphicons-halflings-regular.ttf
    create-file "$yawsbootstrapfontwoff" \
        $project/www/fonts/glyphicons-halflings-regular.woff
}

post-create () {
    local project=$1
    cd $project && add-git-files && mkdir -p deps && make check-all-with-deps
}

setup-script-project () {
    local script=$1
    create-file "$scriptfile" $script
    chmod 755 $script
}

setup-library-project () {
    echo "Setting up starter library project ..."
    local project=$1
    create-dirs $project
    create-project-files $project
    create-library-files $project
    post-create $project
}

setup-service-project () {
    echo "Setting up starter OTP service project ..."
    local project=$1
    create-dirs $project
    create-project-files $project
    create-service-files $project
    post-create $project
}

setup-e2-service-project () {
    #echo "Setting up starter e2 service project ..."
    local project=$1
    not-implemented-error
}

setup-yaws-project () {
    echo "Setting up default starter YAWS project ..."
    local project=$1
    create-dirs $project
    create-yaws-dirs $project
    create-project-files $project
    create-yaws-files $project
    post-create $project
}

setup-yaws-bootstrap-project () {
    echo "Setting up Bootstrap starter YAWS project ..."
    local project=$1
    create-dirs $project
    create-yaws-dirs $project
    create-yaws-bootstrap-dirs $project
    create-project-files $project
    create-yaws-files $project
    create-yaws-bootstrap-files $project
    post-create $project
}

create-new-yaws () {
    local command=$1
    local subcommand=$2
    local arg=$3
    case $subcommand in
        default)
            setup-yaws-project $arg
            ;;
        bootstrap)
            setup-yaws-bootstrap-project $arg
            ;;
        simple)
            setup-yaws-simple-project $arg
            ;;
        *)
            unknown-subcommand-error $command $subcommand
            ;;
    esac
}

create-new () {
    local context=$1
    local arg1=$2
    local arg2=$3
    case $context in
        script)
            setup-script-project $arg1
            ;;
        library)
            setup-library-project $arg1
            ;;
        service)
            setup-service-project $arg1
            ;;
        e2service)
            setup-e2-service-project $arg1
            ;;
        yaws)
            # check if arg2 is empty string; if so, assume no subcommand was
            # passed and use the default subcommand
            if [ "$arg2" == "" ]; then
                arg2=$arg1
                arg1="default"
            fi
            create-new-yaws $context $arg1 $arg2
            ;;
        *)
            unknown-context-error $context
            ;;
    esac
}

install () {
    local context=$1
    local arg1=$2
    local arg2=$3
    # the default option is to install lfetool itself
    if [ "$context" == "" ]; then
        context="lfetool"
    fi
    case $context in
        lfetool)
            install-lfetool $arg
            ;;
        lfe)
            install-lfe
            ;;
        erlang)
            install-erlang $arg1 $arg2
            ;;
        kerl)
            install-kerl
            ;;
        rebar)
            install-rebar
            ;;
        relx)
            install-relx
            ;;
        *)
            unknown-context-error $context
            ;;
    esac
}

do-tests () {
    case $context in
        unit)
            run-unit-tests
            ;;
        integration)
            run-integration-tests
            ;;
        system)
            run-system-tests
            ;;
        all)
            run-all-tests
            ;;
        build)
            build-tests
            ;;
        show-unit)
            get-unit-tests
            ;;
        show-integration)
            get-integration-tests
            ;;
        show-system)
            get-system-tests
            ;;
    esac
}

check-context () {
    local context=$1
    if [ "$context" = "" ]; then
        missing-context-error
    fi
}

check-arg () {
    local arg=$1
    if [ "$arg" = "" ]; then
        missing-arg-error
    fi
}

run () {
    if [ "$0" == "bash" ]; then
        # this script is being executed by the wrapper
        local script=$1
        local version=$2
        local command=$3
        local context=$4
        local arg1=$5
        local arg2=$6
    else
        # this script is being executed directly
        local script=$0
        local command=$1
        local context=$2
        local arg1=$3
        local arg2=$4
    fi

    case $command in
        -h)
            echo
            print-usage $script $version
            exit 0
            ;;
        -v)
            echo "$version"
            exit 0
            ;;
        -x)
            echo "Script has already been extracted."
            exit 1
            ;;
        help)
            $script -h
            ;;
        version)
            $script -v
            ;;
        extract)
            $script -x
            ;;
        install)
            check-context $context
            install $context $arg1 $arg2
            ;;
        new)
            check-context $context
            check-arg $arg1
            create-new $context $arg1 $arg2
            exit 0
            ;;
        update)
            update-lfetool
            exit 0
            ;;
        tests)
            do-tests
            ;;
        *)
            unknown-command-error $command
            ;;
    esac
}

run $@
